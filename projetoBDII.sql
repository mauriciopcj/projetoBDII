--DROP TABLE Grupo;
CREATE TABLE Grupo (
	nome varchar(50) NOT NULL,
	matricula char(11) NOT NULL
);

INSERT INTO Grupo VALUES ('Mauricio Pereira', '20181370027');
INSERT INTO Grupo VALUES ('Renato Borges', '20171370013');
INSERT INTO Grupo VALUES ('Romero Reis', '20181370009');

--DROP TABLE Conta;
CREATE TABLE Conta (
	numConta char(11) NOT NULL CHECK(char_length(numConta)=11),
	dig char(1) NOT NULL CHECK(dig SIMILAR TO '([0-9]|&)'),
	nome varchar(50) NOT NULL,
	tipo char(1) NOT NULL CHECK(tipo SIMILAR TO '(A|S)'),
	ativa char(1) NOT NULL CHECK(ativa SIMILAR TO '(S|N)'),
	CONSTRAINT PK_conta PRIMARY KEY (numConta)
);

--DROP TABLE Saldos;
CREATE TABLE Saldos (
	numConta char(11) NOT NULL,
	ano int NOT NULL,
	saldo numeric(9,2) NOT NULL,
	CONSTRAINT PK_saldos PRIMARY KEY (numConta, ano),
	CONSTRAINT FK_saldos_conta FOREIGN KEY (numConta) REFERENCES Conta (numConta)
);

--DROP TABLE DebCred;
CREATE TABLE DebCred (
	numConta char(11) NOT NULL,
	mesAno char(6) NOT NULL,
	credito numeric(11,2) NOT NULL,
	debito numeric(11,2) NOT NULL,
	CONSTRAINT PK_debcred PRIMARY KEY (numConta, mesAno),
	CONSTRAINT FK_debcred_conta FOREIGN KEY (numConta) REFERENCES Conta (numConta)
);

--DROP TABLE MovDebCred;
CREATE TABLE MovDebCred (
	numConta char(11) NOT NULL,
	nsu int NOT NULL GENERATED BY DEFAULT AS IDENTITY, 
	dig char(1) NOT NULL,
	data timestamp NOT NULL,
	debCred char(1) NOT NULL CHECK(debCred SIMILAR TO '(D|C)'),
	valor numeric(11,2) NOT NULL,
	CONSTRAINT PK_movdebcred PRIMARY KEY (numConta, nsu)
);

/* VIEW - 7.2 */

CREATE VIEW viu as (SELECT
	
	debcred.numconta,
	
	SUBSTRING(debcred.mesano FROM 3 FOR 4) as ano,
	
	saldos.saldo AS "anterior", 
	
	SUM(debCred.credito) AS "totCred", 
	
	SUM(debCred.debito) AS "totDeb", 
	
	(saldos.saldo + SUM(debCred.credito) - SUM(debCred.debito)) AS "atual"
	
FROM Saldos RIGHT OUTER JOIN DebCred ON Saldos.numConta = DebCred.numConta
	
	where CAST(substring(debCred.mesAno FROM 3 FOR 4) AS integer) = CAST(date_part('year', CURRENT_DATE) as integer)
	
GROUP BY 1,2,3
	);

/* TRIGGER  */


CREATE OR REPLACE FUNCTION has_superior_accounts()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
	DECLARE
		total_superior_accounts smallint;
    BEGIN
		total_superior_accounts := (
			SELECT COUNT(*) FROM conta
			WHERE numconta LIKE get_last_account_level(NEW.numconta)
		);
		IF total_superior_accounts < 1 AND get_account_level(NEW.numconta) > 1 THEN
			RAISE EXCEPTION E'Account % does not have any superiors', NEW.numconta;
		END IF;
		RETURN NEW;
	END;
$$;


CREATE TRIGGER validate_account_number BEFORE INSERT ON conta
FOR EACH ROW EXECUTE PROCEDURE has_superior_accounts();

/* STORED PROCEDURE - 7.3.b */

CREATE PROCEDURE transporte(anoS integer)
AS $$
DECLARE
	numconta varchar(11) :='';
	saldo numeric := 0;
	cred numeric := 0;
	deb numeric := 0;
	total numeric := 0;
	linha RECORD;
BEGIN
	FOR linha in SELECT debcred.numconta as conta, saldos.saldo as sald, sum(debcred.credito) as credito, sum(debcred.debito) as debito
	FROM saldos RIGHT OUTER JOIN debcred ON saldos.numconta = debcred.numconta
	WHERE CAST(SUBSTRING(debcred.mesano FROM 3 FOR 4) AS integer) = anoS
	group by 1,2
	LOOP
		IF (linha.sald != NULL) THEN
			saldo = linha.sald;
		END IF;
		numconta := linha.conta;
		cred := linha.credito;
		deb := linha.debito;
		total := saldo+cred-deb;
		INSERT INTO saldos (numconta, ano, saldo)
		VALUES (numconta, anoS+1, total);
	END LOOP;
END; $$
LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION critica (mes integer, ano integer)
RETURNS TABLE (identificador integer,
			   numero_conta char(11),  
			   dig_insert char(1), 
			   dig_ok varchar(1), 
			   tipo_conta char(1))
AS $$
DECLARE
BEGIN
	RETURN QUERY SELECT mdc.nsu, mdc.numconta, mdc.dig, verifica_digito(mdc.numconta), conta.tipo
	FROM (SELECT * FROM MovDebCred WHERE CAST(to_char(data, 'MM') as integer) = mes
	AND CAST(to_char(data, 'YYYY') as integer) = ano ORDER BY numconta, debcred) AS mdc 
	LEFT OUTER JOIN conta ON conta.numconta = mdc.numconta
	WHERE conta.tipo = 'S' OR mdc.dig <> verifica_digito(mdc.numconta) OR conta.numconta IS NULL;
END; 
$$ LANGUAGE 'plpgsql';

/* STORED FUNCTION - 7.4.a */

CREATE OR REPLACE FUNCTION verifica_digito (numero varchar)
RETURNS varchar
AS $$
DECLARE
	mascara varchar := '27654327654';
	soma integer := 0;
	resto integer;
	digito varchar;
BEGIN
	FOR i IN 1..11 LOOP
		soma = soma + CAST(substring(numero from i for 1) AS integer) * CAST(substring(mascara from i for 1) AS integer);
	END LOOP;
	resto := soma % 11;
	digito := 11 - resto;
	IF digito = '10' THEN
		digito := '0';
	ELSIF digito = '11' THEN
		digito := '&';
	END IF;
	RETURN digito;
END; 
$$ LANGUAGE 'plpgsql';

/* STORED FUNCTION - 7.4.b */

CREATE OR REPLACE FUNCTION saldo_atual (numero varchar, mes integer, anoNovo int)
RETURNS TABLE (
	saldo_anterior numeric(9,2),
	tot_credito numeric(9,2),
	tot_debito numeric(9,2),
	saldo_atual numeric(9,2)
)
AS $$
BEGIN
	RETURN QUERY
		SELECT saldos.saldo AS "anterior", 
			SUM(debCred.credito) AS "totCred", 
			SUM(debCred.debito) AS "totDeb", 
			saldos.saldo + (debCred.credito - debCred.debito) AS "atual"
		FROM Saldos JOIN DebCred ON Saldos.numConta = DebCred.numConta
		WHERE saldos.ano = anoNovo
			AND debCred.numConta = numero
			AND CAST(substring(debCred.mesAno FROM 1 FOR 2) AS integer) <= mes
			AND CAST(substring(debCred.mesAno FROM 3 FOR 4) AS integer) = anoNovo
		GROUP BY 1, 4;
		
END; 
$$ LANGUAGE 'plpgsql';


CREATE OR REPLACE PROCEDURE atualizaTabelaDebCred(
	mesS integer,
	anoS integer
)
LANGUAGE 'plpgsql'
AS $$
	DECLARE
		linha RECORD;
		selected_mesano varchar := CONCAT(
			LPAD(CAST(mesS AS varchar), 2, '0'), CAST(anoS AS varchar)
		);
		total_deb int := 0;
	BEGIN
		IF NOT critica_checagem(mesS, anoS) THEN
			RAISE EXCEPTION 'Dados inconsistentes verifique a critica';
		END IF;
		FOR linha IN SELECT mv.numconta AS numconta, mv.debcred, SUM(mv.valor) AS total_cred
			FROM MovDebCred AS mv JOIN conta AS conta ON conta.numconta = mv.numconta
			WHERE date_part('month', mv.data) = mesS AND date_part('year', mv.data) = anoS AND
			conta.tipo = 'A' AND conta.ativa = 'S' AND mv.debcred = 'C'
			GROUP BY mv.numconta, mv.debcred
			ORDER BY numconta LOOP
                SELECT INTO total_deb SUM(valor) FROM MovDebCred
                    WHERE date_part('month', data) = mesS AND date_part('year', data) = anoS AND
                    numConta = linha.numConta AND debcred = 'D';
				IF total_deb IS NULL THEN
					total_deb := 0;
				END IF;
                INSERT INTO DebCred (numConta, mesano, credito, debito) 
                    VALUES (
                        linha.numConta,
                        selected_mesano,
                        linha.total_cred,
                        total_deb
                    );
				CALL update_superior_accounts(linha.numConta, selected_mesano, linha.total_cred, total_deb);
				COMMIT;
		END LOOP;
	END;
$$;



CREATE OR REPLACE PROCEDURE update_superior_accounts(
	numcontaN varchar,
	mesanoN varchar,
	creditoN numeric,
	debitoN numeric
)
LANGUAGE plpgsql
AS $$
	DECLARE
		superior_conta varchar := get_last_account_level(numcontaN);
    BEGIN
		IF get_account_level(numcontaN) = 1 THEN
			RETURN;
		END IF;
		INSERT INTO DebCred AS dc (numConta, mesano, credito, debito) 
			VALUES (
				superior_conta,
				mesanoN,
				creditoN,
				debitoN
			) ON CONFLICT (numConta, mesano) DO UPDATE
				SET credito = dc.credito + creditoN, debito = dc.debito + debitoN;
		CALL update_superior_accounts(superior_conta, mesanoN, creditoN, debitoN);
	END;
$$;


/* FORMATA NUMERO DE CONTA DE INTEIRO PARA STRING COM MASCARA (pontos) */

CREATE OR REPLACE FUNCTION format_account_number( account_number VARCHAR )
RETURNS VARCHAR
LANGUAGE 'plpgsql'
AS $$
	DECLARE
		mask VARCHAR := 'X.X.XX.XX.XXX.XX';
		formated_value VARCHAR := '';
		interator integer := 1;
	BEGIN
		FOR i IN 1..16 LOOP
			IF substring(mask from i for 1) = 'X' THEN
				formated_value = CONCAT(
					formated_value,
					substring(account_number from interator for 1)
				);
				interator = interator + 1;
			ELSE
				formated_value = CONCAT(formated_value, '.');
			END IF;
		END LOOP;
		RETURN formated_value;
	END;
$$;

/* REMOVE FORMATO NUMERO DE CONTA */

CREATE OR REPLACE FUNCTION unformat_account_number( formated_account_number varchar )
RETURNS varchar
LANGUAGE 'plpgsql'
AS $$
	BEGIN
		RETURN REPLACE(account_number, '.', '');
	END;
$$;


/* PEGAR LEVEL DA CONTA PELO NUMERO DE CONTA FORMATADO */

CREATE OR REPLACE FUNCTION get_account_level( account_number varchar )
RETURNS smallint
LANGUAGE 'plpgsql'
AS $$
	DECLARE
		counter smallint := 0;
		reversed_acc varchar;
	BEGIN
		reversed_acc := REVERSE(format_account_number(account_number));
		FOR i IN 1..16 LOOP
			IF substring(reversed_acc from i for 1) = '0' THEN
				CONTINUE;
			ELSIF substring(reversed_acc from i for 1) = '.' THEN
				counter = counter + 1;
			ELSE
				EXIT;
			END IF;
		END LOOP;
		RETURN 6 - counter;
	END;
$$;


/* PEGAR COMEÃ‡O DA CONTA SUPERIOR */

CREATE OR REPLACE FUNCTION get_last_account_level( account_number varchar )
RETURNS varchar
LANGUAGE 'plpgsql'
AS $$
	DECLARE
		last_level smallint;
		cleaver smallint;
	BEGIN
		last_level := get_account_level(account_number);
		CASE last_level
			WHEN 2 THEN
				cleaver := 1;
			WHEN 3 THEN
				cleaver := 2;
			WHEN 4 THEN
				cleaver := 4;
			WHEN 5 THEN
				cleaver := 6;
			WHEN 6 THEN
				cleaver := 9;
			ELSE
				--  do nothing
		END CASE;
		RETURN RPAD(
			substring(
				account_number
				from 1 for cleaver
			),
			11,
			'0'
		);
	END;
$$;


CREATE OR REPLACE FUNCTION critica_checagem (mes integer, ano integer)	
RETURNS BOOLEAN AS $$	
DECLARE
	tipo char(1);
	linha RECORD;
BEGIN
	FOR linha IN (SELECT mdc.numconta, mdc.dig
	FROM movdebcred as mdc
	WHERE CAST(to_char(mdc.data, 'MM') as integer) = mes
	AND CAST(to_char(mdc.data, 'YYYY') as integer) = ano) LOOP
		SELECT INTO tipo conta.tipo
			FROM conta
			WHERE conta.numconta = linha.numconta;
		IF linha.numconta = null THEN
			RETURN FALSE;
		ELSIF verifica_digito(linha.numconta) != linha.dig THEN
			RETURN FALSE;
		ELSIF  tipo = 'S' THEN
			RETURN FALSE;
		END IF;
	END LOOP;
	RETURN True;
END;	
$$ LANGUAGE 'plpgsql';
